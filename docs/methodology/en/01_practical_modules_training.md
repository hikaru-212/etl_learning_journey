# Practical Modules Training Plan

## Purpose
This is the **second stage** of my foundational training.  
Stage 00 focused on first-principles and architecture; this stage emphasizes **hands-on practice** with module-based Python exercises.

---

## Training Structure
Each module includes **5 base exercises** and **3 LeetCode Easy** problems.

---

### Module A: Control Flow Basics
**Focus:** loops, conditionals, decomposition.

**Base (5)**
1. FizzBuzz
2. Find max/min from a list
3. Compute cumulative sum and running average
4. Count positives / negatives / zeros in a list
5. Print an NÃ—N multiplication table

**LeetCode Easy (3)**
- 1480. Running Sum of 1d Array
- 1295. Find Numbers with Even Number of Digits
- 268. Missing Number

---

### Module B: Lists & Dictionary Operations
**Focus:** collections, lookups, in-place edits, frequency maps.

**Base (5)**
1. Two-sum (hash-map version)
2. Remove duplicates while preserving order
3. Reverse list in place vs. slicing
4. Build a frequency dict from a list
5. Intersection / union of two lists

**LeetCode Easy (3)**
- 1. Two Sum
- 217. Contains Duplicate
- 350. Intersection of Two Arrays II

---

### Module C: String Processing
**Focus:** parsing, normalization, combinatorics on strings.

**Base (5)**
1. Palindrome check (ignore case/non-letters)
2. Valid anagram (two methods: sort vs. count)
3. Count vowels/consonants
4. Reverse words in a sentence
5. Remove vowels / keep only alphanumerics

**LeetCode Easy (3)**
- 125. Valid Palindrome
- 242. Valid Anagram
- 387. First Unique Character in a String

---

### Module D: Iteration & Aggregation
**Focus:** sliding windows, grouping, summarization.

**Base (5)**
1. Sliding window sum (size k)
2. Group numbers by parity / by length
3. Build character histogram and sort by freq
4. Chunk a list into size-k batches
5. Merge intervals (baseline iterative approach)

**LeetCode Easy (3)**
- 704. Binary Search
- 121. Best Time to Buy and Sell Stock
- 169. Majority Element

---

### Module E: Recursive Thinking
**Focus:** recursion, memoization, divide & conquer.

**Base (5)**
1. Factorial (with/without memoâ€”not needed but for pattern)
2. Fibonacci (memoized)
3. Power function `pow(x, n)` (fast power)
4. Sum of digits / digital root (recursive)
5. Flatten nested lists

**LeetCode Easy (3)**
- 509. Fibonacci Number
- 344. Reverse String (recursive implementation)
- 100. Same Tree

---

### Module F: Stack, Queue & Counting
**Focus:** LIFO/FIFO mechanics, counters.

**Base (5)**
1. Valid parentheses (stack)
2. Implement a queue using two stacks
3. Simple undo/redo buffer (stack pairs)
4. Rotate queue by k steps
5. Character frequency with `collections.Counter`

**LeetCode Easy (3)**
- 20. Valid Parentheses
- 232. Implement Queue using Stacks
- 225. Implement Stack using Queues

---

### Module G: Functions & Techniques
**Focus:** idiomatic Python; functional patterns.

**Base (5)**
1. `*args` / `**kwargs` sum & key-value merge
2. Sort with `key=` (e.g., by length, then lexicographic)
3. `map` / `filter` pipelines on lists
4. `reduce` to compute product / gcd
5. Default-parameter memoization pattern

**LeetCode Easy (3)**
- 1480. Running Sum of 1d Array (functional pipeline version)
- 709. To Lower Case
- 1108. Defanging an IP Address

---

## Daily Routine
- Solve 2â€“3 tasks per session (mix base + LeetCode).
- After solving, **explain your reasoning** in plain English.
- Revisit problems after a few days for spaced repetition.

## Expected Outcome
- Fluency in core Python patterns and data handling.
- Ability to map common tasks to reusable templates.
- Stronger reflexes bridging theory (Stage 00) and practice (Stage 1).

ðŸ‘‰ Follows: [00 Foundational Training Plan](./00_foundational_training_plan.md)
